for each item here, identify if it's a bug or a new feature. if it's a new feature, assess whether it's large and has multiple open questions about it.  if it is large, follow the @thinking/from-thinking-to-coding/ methodology to understand the feature and implement it in phases.

add pointers to specs, implementation plans and any other documentation if any are created for any of the items.

update the status of each of the items below.  mrak them as "in progress" once you start working on it.  mark it as "implemented" when it has been impelemented in code, but not yet confirmed to be fully working.

when it's fully working, move it to a todo-done.md file

---

# ai chat issues
  - Type: bug / enhancement
  - Status: implemented
  - Plan: .cursor/plans/ai_chat_issues_implementation_03a3c2c7.plan.md

## 1) chat persistence
  - Status: implemented

the chat needs to be preserved.  both my prompts and the llm responses.  they should be restored upon reload.  each message should have a timestamp that is displayed with the message.  for chats in meetings, it should be stored in the meeting's json.  for the chat in the main home page, we should create a new homepage_state.json that keeps this.  

  Implementation notes:
  - Backend: 4 new API endpoints in chat.py (GET/PUT for meeting and homepage chat history)
  - MeetingStore: get_chat_history() / save_chat_history() read/write chat_history in meeting JSON
  - ChatService: get_homepage_chat_history() / save_homepage_chat_history() read/write data/homepage_state.json
  - Frontend: ChatUI accepts historyEndpoint option; loadHistory() on init, saveHistory() after each send/response cycle and clear
  - Messages now stored as {role, content, timestamp} with ISO timestamps displayed as relative/short datetime
  - app.js passes historyEndpoint: "/api/chat/homepage/history"
  - meeting.js passes historyEndpoint: `/api/chat/meeting/${state.meetingId}/history`

## 2) chat search
  - Status: implemented

the chat can get quite long, so let's add a search box at the top in the chat panel banner.  typing text here should do a case insensitive search in the chat window.  this search needs a "next" and "prev" just like search in most text editors. this needs to happen for both homescreen chat and meeting chat.

  Implementation notes:
  - Search bar added to all ChatUI variants (fullscreen, minimal, standard) in chat.js
  - Ctrl+F / Cmd+F opens search when chat panel is focused
  - Case-insensitive search with <mark> highlighting across all .chat-message-content elements
  - Next/Prev navigation with wrapping, Enter/Shift+Enter shortcuts, Escape to close
  - Count display shows "N/M" (current match / total matches)
  - CSS styles for .chat-search-bar, mark, mark.current in styles.css

## 3) attendee names in chat context
  - Status: implemented

in the meeting chat if i rename an attendee, then ask the llm about that attendee by the new name, the llm doesn't know about it. what's the best way to fix this?  if i refer to this person by name in the main homescreen ai chat, it also needs to know about the attendee by their new name.  

  Implementation notes:
  - Added _format_transcript_with_speakers() and _format_attendee_list() helpers to ChatService
  - All 3 transcript formatting locations now resolve speaker_id to attendee name using the meeting's attendees list
  - Attendee list included in prompt context so LLM knows meeting participants
  - Works for both meeting chat and overall chat (renamed names are resolved from the meeting JSON)

---

# user notes feature
  - Type: new feature
  - Size: medium
  - Status: not started

purpose: we want to enable the user to type in notes and have it logged in time with the topic being discussed at that moment.  but we need to recognize that the note taken might come a bit later than the actual discussion due to natural lag.  

how this should work.

when the user starts writing a note, take a timestamp for when the user starts.  have a "submit" button with the notes.  when the user hits "submit" it should be added logged above the notes entry box.  keep a running log of all notes.   the user should be able to go back to any note and edit it.  this should not change the original timestamp.

the timestamp must be in the same format and basis as the transcript timestamp because we want the llm to know approximately what the note is referring to.

the notes field should also have an 'x' button taht clears the notes field.  if the user hits this and then starts a new note, there should be a new timestamp.

whenever the system summarizes the transcript, it should include these notes and the appropriate timestamp so that the llm knows what the user has said.  combine all of this to generate the summary.

---

# update to attendee list
  - Type: new feature
  - Size: medium
  - Status: implemented

update the attendees ui to make it easier to identify and update the attendees.  the ui should show a list of each attendee.  when i select any person, there should be a text box on the right side that shows what the person has said so far to help me know who it is.

i should be able to rename the person selected.  give me a rename button that puts it in rename mode that does rename in place, similar to how file renames work.   

give me a button that does auto-rename.  this should prompt the ai to identify the name of the person based upon the conversation content.

  Implementation notes:
  - Replaced textarea with interactive attendee list (left column)
  - Selecting an attendee shows their spoken segments (right column)
  - Rename button enables inline editing (Enter to save, Escape to cancel)
  - Auto button calls AI to identify speaker name from their speech
  - Backend API: POST /api/meetings/{id}/attendees/{id}/auto-rename
  - Added `prompt()` method to all LLM providers for raw prompts

---

# user login
  - Type: new feature
  - Size: large (multi-step, open questions: auth provider, scopes, privacy, multi-user storage layout)
  - Status: deferred
  - Docs: docs/specs/user-login-spec.md, docs/plans/user-login-plan.md

create a user login.  can we connect this to google identiy login?  let the user profile be connected to google and also get access to the user's google drive?

change the file storage to be structured for multiple users and load the meeting configurations and the settings to be per user.  make it so that each person's login get their own meetings and settings

---

# e2e test harness
  - Type: new feature
  - Size: medium
  - Status: implemented
  - Docs: docs/specs/e2e-test-harness-spec.md, docs/plans/e2e-test-harness-plan.md

end-to-end test harness for automated testing of in-progress features.
trigger via URL: /test?suite=<id> or /test?all=true
outputs detailed logs to logs/test_*.log
